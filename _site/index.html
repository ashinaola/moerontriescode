<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Home
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | moerontriescode.com</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="Moeron tries to review computer science concepts">
<meta property="og:description" content="Moeron tries to review computer science concepts">
<link rel="canonical" href="http://localhost:4000/">
<meta property="og:url" content="http://localhost:4000/">
<meta property="og:site_name" content="moerontriescode.com">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:00:00-08:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","dateModified":"1900-01-01T00:00:00-08:00","datePublished":"1900-01-01T00:00:00-08:00","description":"Moeron tries to review computer science concepts","headline":"Index","name":"moerontriescode.com","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="Moeron tries to review computer science concepts">
        <link rel="preload" href="/assets/img/selfghibili.webp" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>moerontriescode.com</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/selfghibili.webp" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="Asymptotic Notation">
            <div class="nav-item">
                <a href="/Asymptotic%20Notation/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Asymptotic Notation</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Asymptotic Notation category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Introduction to Asymptotic Notation">
                    <div class="nav-item">
                        <a href="/Asymptotic%20Notation/Introduction%20to%20Asymptotic%20Notation.html" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Introduction to Asymptotic Notation</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Data Structures">
            <div class="nav-item">
                <a href="/Data%20Structures/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Data Structures</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Data Structures category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="Arrays">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Arrays/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Arrays</span>
                        </a><button class="nav-list-expander" aria-label="toggle items in Arrays category" aria-pressed="false">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                        </button>
</div>
<ul class="nav-list">
<li id="nav-third" aria-label="2-D Arrays">
                                <div class="nav-item">
                                    <a href="/Data%20Structures/Arrays/2-D%20Arrays.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>2-D Arrays</span>
                                    </a>
                                </div>
                            </li>
<li id="nav-third" aria-label="Dynamic Arrays">
                                <div class="nav-item">
                                    <a href="/Data%20Structures/Arrays/Dynamic%20Arrays.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>Dynamic Arrays</span>
                                    </a>
                                </div>
                            </li>
<li id="nav-third" aria-label="Introduction to Arrays">
                                <div class="nav-item">
                                    <a href="/Data%20Structures/Arrays/Introduction%20to%20Arrays.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>Introduction to Arrays</span>
                                    </a>
                                </div>
                            </li>
<li id="nav-third" aria-label="Jagged Arrays">
                                <div class="nav-item">
                                    <a href="/Data%20Structures/Arrays/Jagged%20Arrays.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>Jagged Arrays</span>
                                    </a>
                                </div>
                            </li>
</ul>
</li>
<li id="nav-second" aria-label="Balanced Trees">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Balanced%20Trees/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Balanced Trees</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Binary Search Trees">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Binary%20Search%20Trees/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Binary Search Trees</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Binary Trees">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Binary%20Trees/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Binary Trees</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Complete Binary Trees">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Complete%20Binary%20Trees/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Complete Binary Trees</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Full Binary Tree">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Full%20Binary%20Tree/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Full Binary Tree</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Linked Lists">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Linked%20Lists/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Linked Lists</span>
                        </a><button class="nav-list-expander" aria-label="toggle items in Linked Lists category" aria-pressed="false">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                        </button>
</div>
<ul class="nav-list">
<li id="nav-third" aria-label="Doubly Linked Lists">
                                <div class="nav-item">
                                    <a href="/Data%20Structures/Linked%20Lists/Doubly%20Linked%20Lists.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>Doubly Linked Lists</span>
                                    </a>
                                </div>
                            </li>
<li id="nav-third" aria-label="Introduction to Linked Lists">
                                <div class="nav-item">
                                    <a href="/Data%20Structures/Linked%20Lists/Introduction%20to%20Linked%20Lists.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>Introduction to Linked Lists</span>
                                    </a>
                                </div>
                            </li>
</ul>
</li>
<li id="nav-second" aria-label="Queues">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Queues/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Queues</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Stacks">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Stacks/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Stacks</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Unbalanced Trees">
                    <div class="nav-item">
                        <a href="/Data%20Structures/Unbalanced%20Trees/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Unbalanced Trees</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/ashinaola">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:zonedsnoopy@gmail.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                
                
                
                
                    <li><a aria-label="My LinkedIn" href="https://www.linkedin.com/in/Shinaola%20Agbede">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg>
                    </a></li>
                
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>
        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        All Posts
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Data%20Structures/Linked%20Lists/Doubly%20Linked%20Lists.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/doublylinkedlist.gif') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Data%20Structures/Linked%20Lists/Doubly%20Linked%20Lists.html"><h1 class="title_post">Introduction to Linked Lists: Doubly Linked Lists</h1></a>
                        <a href="/Data%20Structures/Linked%20Lists/Doubly%20Linked%20Lists.html" class="txt_post">
                            Linked Lists: Operations

Add()

Remove()

Traverse()

Search()

Sort()

Linked Lists: Application and Uses

‘Real World’ Projects and Uses of Linked Lists

                        </a>
                        <div class="info-post">
                                <a href="/Data%20Structures" class="category">Data Structures</a>
                            
                                <span class="date">· 2025-06-13</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Data%20Structures/Linked%20Lists/Introduction%20to%20Linked%20Lists.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/linkedlist.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Data%20Structures/Linked%20Lists/Introduction%20to%20Linked%20Lists.html"><h1 class="title_post">Introduction to Linked Lists</h1></a>
                        <a href="/Data%20Structures/Linked%20Lists/Introduction%20to%20Linked%20Lists.html" class="txt_post">
                            Linked Lists: Operations

Add()

Remove()

Traverse()

Search()

Sort()

Linked Lists: Application and Uses

‘Real World’ Projects and Uses of Linked Lists

                        </a>
                        <div class="info-post">
                                <a href="/Data%20Structures" class="category">Data Structures</a>
                            
                                <span class="date">· 2025-06-09</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Data%20Structures/Arrays/Jagged%20Arrays.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/jaggedarray.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Data%20Structures/Arrays/Jagged%20Arrays.html"><h1 class="title_post">Jagged Arrays: Taking Them to the Next Level</h1></a>
                        <a href="/Data%20Structures/Arrays/Jagged%20Arrays.html" class="txt_post">
                            There are several types of arrays which can be serve different purposes.  While there are more types, the main focus will be on jagged arrays.  The characteristic of this data structure can be summarized as an ‘array of arrays’.  The jagged array is made of arrays of different sizes or lengths.  The jagged arrays may have some differences compared with the introduced static array.  For example, the composition of arrays adds another dimension to the structure relative to the static array.

Operations
As previously mentioned, jagged arrays set themselves apart from 2-D arrays due to the fact that it is comprised of arrays of different lengths.  This would alter how inserts, deletes, searches, and traversals are implemented.  It can also alter the runtime of the operations, due to the additional dimension which adds another layer of traversal.  By creating a code segment, it is easier to demonstrate how the operations work and are implemented.  The code to initiate the jagged array will be as follows:

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class JaggedArray {
public:
    vector&lt;string&gt; outerArray;

    JaggedArray() {
        // Optional: initialize or log something
    }
}


The array will take in a file which has several addresses and store them in the structure.  By creating this structure, it is possible to organize text file contents into an array and make it easier to merge several text files together, for example.  While the original idea behind the jagged array is to have an array of arrays which are static, the outer array of the jagged array will be a vector instead.  Vectors are essentially dynamic arrays which can grow in order to accomodate more data than initally reserved.  This property will allow us to take in more lines from text files, which will allow us to easily concatenate two text files of addresses into one single jagged array.

Insert
After creating the jagged array structure, the first operation to work on would be the insert operation.  The steps of the insert() would go as follows:

  
    Take in the string array which represents a row in the text file.
    Add the string array to the vector.
  


Added elements in this example would be arrays of strings which were created by reading in a file line by line.  Again, what would make this array jagged is the fact that each string will have a different amount of indices.  If the arrays which were added all shared the same length, it would be a 2-D array instead of an jagged array.  The following is a code snippet, representing the function which performs inserts for the jagged array:

void insertElement(string[addrSize] addr) {
    outerArray.push_back(addr);
}


Delete
After adding elements to the jagged array, there should be a way for the operation to be undone.  This will allow for elements to be deleted after being added.  For example, if the wrong or corrupted array is entered, the data structure can undo the operation by executing a delete function.  There can be several ways for a jagged array to execute a delete.  One way is for the function parameters to provide the element index, so that the proper indices are freed:
void deleteElement(int index){
    // delete action goes here
}

Another way is for the string or string array to be provided and then search for the matching entrance.  While this can be ideal when the element indices are unknown, the first methodology would be more efficient due to the worst case search being O(\(n^2\)).  Deleting an element from the outer vector will run at constant time, which is a better implentation of the delete operation, despite the difference in signature:
void deleteElement(int index) {
    if (!outerVector.empty()) {
        if (index &gt;= 0 &amp;&amp; index &lt; outerVector.size()) {
            outerVector.erase(outerVector.begin() + index);
        } else {
            std::cout &lt;&lt; "Invalid index: Out of bounds." &lt;&lt; std::endl;
        }
    } else {
        std::cout &lt;&lt; "Empty vector: Please insert elements." &lt;&lt; std::endl;
    }
}

The code segment will check the length to make sure that the vector has elements to remove before proceeding to delete the element at the provided index.  The index can be provided either directly by the user or by another function, search() which will return the index of the matching function.  The output from the search can be used as the function parameter of the deleteElement() funtion.

Traverse
The traversal operation for the jagged array is different from the static array, or dynamic array (vector) due to its property of having multiple dimensions.  However, unlike the 2-D array, the jagged array is not perfectly 2-D.  Technically, traversing the jagged array will take \(\lt\) O(\(n^2\)).  For practical purposes, it is easier for the traversal to be counted as running in the worst case of O(\(n^2\)) runtime.

To execute the traversal of the jagged array, it must start at the initial index and traverse down each element in the vector.  Since each element is an array, the array is traversed before moving to the next element in the vector.  This would call for a nested loop as shown:
void traversal() {
    for (int i = 0; i &lt; outerArray.size(); ++i) {
        std::cout &lt;&lt; "Row " &lt;&lt; i &lt;&lt; ": ";
        for (int j = 0; j &lt; outerArray[i].size(); ++j) {
            std::cout &lt;&lt; outerArray[i][j] &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }
}


Linear Search
As mentioned in the introductory section, searches in jagged arrays are similar in the sense that the operation aims to find the matching element and return the index.  There are multiple ways searches can be conducted. Depending on the size of the jagged array being searched, the appropriate search method with the correct runtime should be used as the search function’s algorithm.  Since the input size will not be too large, a simple search algorithm which takes o(\(n^2\)) runtime will be acceptable, however it will not be the best search if the jagged array were to grow upwards in size.  This would exponentially increase the amount of comparisons which would slow down the execution time of the program.  It would be appropriate to adjust the search to an algorithm which runs at a faster runtime.

The code segment of the search will start at the first element or the array and assess whether the strings match, before traversing down the inner-array until an unmatching element is met.  If a string doesn’t match, then the algorithm should move to the next element and traverse down.  If the end of the array is met, the loop can be stopped and the index of the matching array returned by the function.  Here is a snippet of the function:
int search(string addr[]) {
    for (int i = 0; i &lt; outerArray.size(); ++i) {
        if (outerArray[i] == addr) {
            return i; // Found a match at index i
        }
    }
    return -1; // Not found
}


Jagged Arrays: Uses and Examples
In this example, the goal is to utilize the jagged array to take two different text files of addresses and merge them into a singular storage location, which will be the jagged array.  The jagged array can offer a singular location for content distributed across different text files, a singular location to manage the addresses.  The challenge is to create a tokenizer, so that the read-in lines can be plugged into the data structures and then read each line into the jagged array.  By compiling and executing the program, two text files can be merged into the jagged array and display the contents from one single location.


                        </a>
                        <div class="info-post">
                                <a href="/Data%20Structures" class="category">Data Structures</a>
                            
                                <span class="date">· 2025-05-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Data%20Structures/Arrays/Introduction%20to%20Arrays.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/arraypic.gif') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Data%20Structures/Arrays/Introduction%20to%20Arrays.html"><h1 class="title_post">Introduction to Arrays</h1></a>
                        <a href="/Data%20Structures/Arrays/Introduction%20to%20Arrays.html" class="txt_post">
                            In many situations, the ability to take multiple values and assign them to one variable is can be desired.  For example, if you want to keep track of the highest scores of a game and display them, it would help to have a running list of scores to compare against.  Arrays are a way to store values to be retrieved later.  Due to its versatile nature, it has been used in many different solutions and algorithms.

An array is usually the first data structure that is introduced due to its intuitive nature.  This is because an array is defined as an contiguous block of memory.  As such, arrays usually are defined and limited to a single type as well as the length.  There is a different form of array, considered dynamic arrays, which can adjust its length as more elements are added to the array.  However, since the memory block is defined upon initiation of the array, the array length itself can not be extended.

Arrays: Operations
Arrays are normally zero-indexed (with the exception of some languages such as Lua) which means that the array indexes start at 0 and increases as the it is being traversed.  The usefulness of the indexes allow for elements to be stored and retrieved easily, which makes it a useful basic structure to utilize when storing data.  Arrays normally offer five operations; insertion, deletion, traversal, searching, and sorting, which make them useful in applying them to solve different problems.  The indexed property of the array allows for the elements of the data structure to be organized and retrieved in constant time, which would allow for programs to store larger amounts of data.

To demonstrate the five operations, an array which holds integers will be initialized.  Even though the operations are being applied to integers, the same actions can be applied to strings, characters, floats/doubles, booleans, all the way to objects and structures.  Arrays can even hold other arrays (Refer to 2-D Arrays here). 
To start, an array should be declared as follows:
// declare an array which holds five integers
int[5] demoArray;


  Please note that the code fragments are not complete classes and are not ready to compile


Insertion
The first operation to perform on the array after declaring would be to assign values to the array.  The language that we are utilizing is C++, which means that the types of elements which can be stored in the array is defined at the declaration of the array.  There are other languages which are more flexible with types, such as Javascript and Python, however those structures are a bit different from the traditional array.  When insertion is performed on an array, it executes in constant time.
// insert the first element into the array
demoArray[0] = 1;
demoArray[1] = 2;

The code above takes the integers 1 and 2, then adds them to the index of the array.  This is added in constant time, as the insertion can simply assign the integers by index. Insertions are important since they allow for the data to be stored for later retrievals.  Insertions only can work within the range which was defined.  If an insertion was to be executed to an index that is outside of the defined range, it would result in an Out of Bounds error:
// returns an error due to the index being out of bounds
demoArray[5] = 6;


Deletion
As an static structure, arrays do not have the capability to change its size.  This makes direct deletion of elements not possible, however deletion can be mimicked.  The steps to deleting an element from the array goes as follows:


  
    Find the desired element to delete from the array: 
either through index or matching element
    Shift the remaining elements one space to the left (fill in the gap)
  


Due to the 2nd step, the deletion of an element from an static array gives the worst case runtime of O(\(n\)).  This is because the worst case assumes that the matching element is not found, thus not deleted.  This demonstrates a different runtime from the insertion operation of an static array, which has to be factored when attempting to utilize an static array for an solution.  While there is an advantage with inserting and retrieving elements from the array, deletes are a costlier operation when using the static array.  This trade off should be considered when implementing solutions to various problems.

So to demonstrate an deletion, the previously initialized demoArray would start with two elements after the insertions and end with one element.

  demoArray -&gt; [1,2]
demoArray -&gt; [0,2] , the 1 was deleted
demoArray -&gt; [2,]  , the 2 was shifted one index to the left


Here is the deletion being applied as a function:
void deleteElement(int demoArray[], int&amp; size, int element) {
    int elmIndex = -1;

    // Find the index of the element to delete
    for (int i = 0; i &lt; size; i++) {
        if (demoArray[i] == element) {
            elmIndex = i;
            break;
        }
    }

    if (elmIndex == -1) {
        cout &lt;&lt; "Element not found" &lt;&lt; endl;
        return;
    }

    // Shift elements to the left
    for (int i = elmIndex; i &lt; size - 1; i++) {
        demoArray[i] = demoArray[i + 1];
    }

    // Decrease the size of the array
    size--;
}


Traversal
Traversal is a frequently used operation not only for arrays, but for other data structures as well.  Traversal is where each index or element stored on the structure is visited.  This gives traversal of the array a worst-case runtime of O(\(n\)).  Traversal is central to linear search, where the array is traversed to find a specific element in the array.  It is also utilized to print out array elements, which can be useful for debugging programs to find misallocated or misassigned variables.

Traversal starts on the first index of the array and iterates through the array until it has visited every index on the array.  For some languages, the array’s index will start at 1 (such as Lua), while others start at 0 (such as Javascript, Java, C++, and Python).  The reason is because the loop will either end at the nth index (if it starts at 1) or (n-1)th index.  The following code can be used to execute a traversal:
void traversal(int demoArray[], int&amp; arraySize) {
    // start at the beginning of the array
    int itr = 0;

    // loop through the array and print the element until the end is reached
    while(itr &lt; arraySize) {
        cout &lt;&lt; "element: " &lt;&lt; demoArray[itr] &lt;&lt; endl;
        itr++;
    }
}


Searching
Another operation which are common in arrays is searching, where the provided element is provided and the array is traversed until the desired element is found.  This is a particular style of searching called linear search which has a runtime of O(\(n\)).  There are other forms of search which has faster runtimes which will be explored in other posts, such as binary search, however the focus will be in implementation of linear search.


  Start at the first element
Check if element is matching:
If true: return true and break
Return false


The linear search is one of the introductory searches which students get familiar with and its intuitive approach to finding elements make it a general useful tool for the presented problem of finding the element in a static array.  This code segment is an implementation of a typical linear search, using the demoArray example:
int linearSearch(int demoArray[], int arraySize, int element) {
    for(int i = 0; i &lt; arraySize; i++) {
        if (demoArray[i] == element) {
            return i;
        }
    }
    return -1;
}


Sorting
There are several sorting algorithms which are utilized to sort array contents, however we will not explore them in depth.  Depending on the algorithm, the runtime can range from polynomial to factorial.  The algorithm that we will look at has a quadratic, or O(\(n^2\)), time.  There are several sorting algorithms that can be discussed at this runtime, such as selection and insertion sort, however we will focus on bubble sort.

The goal of all sorting algorithms, including bubble sort, is to take a static array of elements and place the elements in ascending or descending order.  While its runtime is O(\(n^2\)), it does not require any additional memory space and performs relatively well on nearly-sorted arrays.  The main problem with bubble sort is its inefficiency with larger datasets, which may cause it to be less favorable when considering real life applications.  Bubble sort is still a useful algorithm to introduce the sorting problem and work through it with an intuitive solution.

The steps of bubble sort to create an sorted array in ascending order is as follows:


  
    Start at the first index of array (\(reference_1\))
    Start \(reference_2\), traverse down the array
    At each step compare \(reference_2\) to \(reference_1\)
    Swap values if \(reference_1 &gt; reference_2\)
    Continue unitl \(reference_1\) reaches the end
  


The reason for the worst case runtime of O(\(n^2\)) is because of the amount of comparisons which are executed as the first reference is going down the list.  For each index, the algorithm traverses down the list and executes comparisons against each element giving \(n * (n-1)\) or \(n^2\) runtime.  The following is a code snippet of bubble sort:
void bubbleSort(int demoArray[], int arraySize) {
    for (int i = 0; i &lt; arraySize - 1; i++) {
        for (int j = 0; j &lt; arraySize - i - 1; j++) {
            if (demoArray[j] &gt; demoArray[j + 1]) {
                // Swap
                int temp = demoArray[j];
                demoArray[j] = demoArray[j + 1];
                demoArray[j + 1] = temp;
            }
        }
    }
}



Arrays: Examples and uses
Arrays are in wide use in programming and there are many examples where arrays are appropriate to be applied.  For example, it offers a useful data storage mechanism which allows for easy retrieval.  This would make it an ideal solution for any problem which calls for easy retrieval where the index of the desired element is known.  This will take advantage of the array’s constant time retrieval.  In video games, arrays usually store the leaderboard scores which are a common place feature.  By using the sorting operation, the top scores of the game can be ranked and retrieved.

There are other uses for arrays which include listing contacts on a cell phone, image storing on a computer, and many other similar uses.

                        </a>
                        <div class="info-post">
                                <a href="/Data%20Structures" class="category">Data Structures</a>
                            
                                <span class="date">· 2025-05-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Data%20Structures/Arrays/Dynamic%20Arrays.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/dynamicarray.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Data%20Structures/Arrays/Dynamic%20Arrays.html"><h1 class="title_post">Dynamic Arrays: Let's Create and Use One</h1></a>
                        <a href="/Data%20Structures/Arrays/Dynamic%20Arrays.html" class="txt_post">
                            In the introductory post, the concept of static arrays were introduced.  There are several limitations which are associated with static arrays which includes:


  
    a limited amount of space allocated to the array
    shifting elements upon insertion and removal
  


To address the fixed capacity limitation, a pointer can be used to dynamically allocate memory for the array in this way:
int *intarr = new int[size];

The above line of code declares a pointer to the first element of the integer array called intarr.  This allows for the memory to be allocated on the heap, compared to the stack for static arrays.  However, the limitation with dynamic allocation is that the maximum size needed for the array is unknown to begin with.

A dynamic array can address both previously mentioned problems while also introducing better memory management practices.  The dynamic array also preserves the effecient storage and retrievals of static arrays, allowing storage and retrieval to be constant (O(1)) time.

Let’s build a generic template class for a dynamic array, then delve into the some of the operations which set it apart from a typical static array.  Lastly, we will try using the array to store a nondetermined amount of elements to test its flexibility.

Building the Template Class
To begin building the dynamic array template class, the operations would need to be defined.  Most of the operations from the static array would carry over to the dynamic array class but there are a few additions to the dynamic array class which need to be discussed.  The first operation is a destructor or a way to deallocate the memory from the heap since the memory for the array is allocated through the heap.  The second operation is the resize() operation, which checks the array size and expands/shrinks the size as needed.  There are also several differences between the operations to accomodate the dynamic memory allocation and the overhead which it can possibly introduce.

Before diving deeper into the dynamic array class, the design of dynamic array needs to be discussed.  The dynamic array class inherits several attributes and functions from a generic list class called IList.  These attributes and functions can be used by the dynamic array class with some changes to accomodate for heap storage.

Heap Memory Management
To interact with the heap storage, manual allocation is necessary unlike stack storage where memory is automatically allocated and deallocated. The manual allocation of memory can be carried out using the new and delete keywords.  While efficient memory management is introduced, there will be an overhead introduced to carry out the allocation.

There are three attributes which are needed to be introduced to the class to allow the class to interact with heap storage to implement dynamic allocation.  The first attribute is the arr which holds the pointer to the dynamically allocated storage area.  When allocating new space for the array, the new keyword is used alongside with the array in the constructor.  The second attribute is the capacity attribute which represents the total available space in the array.  This is the important attribute which will be used to track the array size to determine whether to expand/shrink the array.  The third attribute is the size attribute, which tracks the current number of elements in the array.  This attribute is one of the attributes that are inherited from the IList class and utilized by the dynamic array class.

To carry out the heap memory management, there needs to be three different constructors which take into account the different cases to which the objects can be initiated.  The first is the default constructor, alongside a constructor to be called with a specified capacity and a constructor which declares a capacity and initial value. Here is the code snippets for each constructor:
// Default constructor
DynamicArray() : IList&lt;T&gt;(),
arr(new T[getDefaultCapacity]),
capacity(getDefaultCapacity()) {}

// Constructor + capacity(capVal)
DynamicArray(size_t capVal) : IList&lt;T&gt;(),
arr(new T[capVal]),
capacity(capVal) {}

// Constructor + capacity(capVal) + initial value(initVal)
DynamicArray(size_t capVal, const T initVal) : IList&lt;T&gt;(),
arr(new T[capVal]),
capacity(capVal) {}

// Destructor for memory deallocation
virtual ~DynamicArray() {
    delete [] arr;
}

Notice the use of the new in the constructors and delete in the destructor to carry out manual memory management through the inclusion of the previously mentioned attribute members.  After creating the constructors and destructors, the interface functions from the IList class can be defined to control how the DynamicArray objects will behave.

resize() Operation
Another major difference between the dynamic and static array definitions is also the resize() operation, which checks the size of the array and then grows/shrinks the array based on the amount of elements that are existing on the array.  The resize() operation is triggered before an element is inserted if the current size of the array is equivalent to the capacity.  Also, before an element is removed, the array’s size is checked to see if the capacity is 3x greater than the array’s current size.  This check is implemented in a single line as demonstrated:
// on adding an element
assert(i &gt;= 0 &amp;&amp; i &lt; size);

// on removing an element
if (capacity &gt;= 3 * size){}

To implement the operation, the resize() function is implemented in 4 general steps:

  
    Initiate a new value for the capacity of the new array
    Initiate a pointer to the new array
    Copy the elements in the old array to the new array
    Destroy the old array and set the capacity to the new capacity
  


These four steps can be incorporated into the insert and remove operations to ensure proper memory management is baked into the implementation of the DynamicArray class.  The complete resize() function for the dynamic array is as follows:
void DynamicArray&lt;T&gt;::resize() {
    // initiate new val for capacity
    size_t new_capacity = std::max(2*static_cast&lt;int&gt;(size), 2);

    // initiate a ptr to new arr
    T* new_arr = new T[new_capacity];

    // Copy elements to new arr
    for (size_t i = 0; i &lt; size; i++)
        new_arr  = arr[i];
    
    // Destroy old arr and set cap to new_arr
    delete[] arr;
    arr = brr;
    capacity = new_capacity;
}


Ways to Optimize the resize() Operation
While the code that was written carries out the resize() operation, it can become a problem when the size of the array starts to grow to a larger size.  As the amount scales up, there might need to be some optimization of the overhead that dynamic arrays present when copying the array over to the new array.  One way of optimizing the for loop in the function is to use std::copy() function to copy the elements to the new array.  This optimization takes advantage of the provided copy algorithm which uses machine instructions to copy the elements over.


  Quick Overview of std::copy()
The copy algorithm provided by C++ takes three different parameters and is in the format copy(start, finish, element) where start and finish defines the index range of the copy and the object is the address of the object where the elements should be copied to.  C++ also provides other algorithms which can also act on overlapping ranges such as std::copy_backwards()


An optimized version of the resize operation replaces the for loop with the copy algorithm as follows:
void DynamicArray&lt;T&gt;::resize() {
    size_t new_capacity = std::max(2 * static_cast&lt;int&gt;(size), 2);
    T* new_arr = new T[new_capacity];
    std::copy(arr, arr + size, new_arr);
    delete[] arr;
    arr = new_arr;
    capacity = new_capacity;
}


                        </a>
                        <div class="info-post">
                                <a href="/Data%20Structures" class="category">Data Structures</a>
                            
                                <span class="date">· 2025-05-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Data%20Structures/Arrays/2-D%20Arrays.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/2Darray.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Data%20Structures/Arrays/2-D%20Arrays.html"><h1 class="title_post">2-D Arrays: Introduction and Examples</h1></a>
                        <a href="/Data%20Structures/Arrays/2-D%20Arrays.html" class="txt_post">
                            In another post, the jagged array tool was introduced as a way to store and retrieve input which have varying length.  The structure was used to store a string of arrays in a vector.  As previously stated, a jagged array is an array which stores arrays of different lengths.  However, if an array were to store elements which were of equal lengths, the jagged array can be treated like an \(m * n\) matrix.  This structure is an 2-D array, which has been used to represent matrices and carry out matrix operations which are extremely useful across different domains.

2-D Array Tradeoffs
To begin, a 2-D array is thought of as an array of arrays.  Another way to think of 2-D arrays is an array whose elements are all arrays of equal length.  This creates a grid-like storage structure which can store elements in a table-like structure which offers the same constant-time retrieval as a single-dimensional array.  To initiate a 2-D array of integers in C++, an array can be initiated with each element being an array as so:
int exArray[4][2] = {
    {1, 2},
    {2, 3},
    {3, 4},
    {4, 5}
};

The code produces a 2 by 4 matrix:
\(\begin{bmatrix}
1 &amp; 2\\
2 &amp; 3\\
3 &amp; 4\\
4 &amp; 5
\end{bmatrix}\)
This will allow for the integer element to be stored and worked with in the same way as one would work with a matrix in linear algebra.  However, while the array can be initiated in this way, modern C++ has offered the vector tool to help assist with memory management.  To use the vector methodology of initiating a 2-D array, a vector of int vectors are initiated as shown:
std::vector&lt;std::vector&lt;int&gt;&gt;

By using vector, memory management is handled and the storage can dynamically adjust to store more elements.

Pros of 2-D Arrays
2-D arrays offer similar retrieval times as a singular array, which allows for the elements to be accessed in constant time.  By preserving the constant-time retrieval of single dimensional arrays, 2-D arrays can allow larger amounts of elements to be stored and retrieved by the program.

Cons of 2-D Arrays
A major advantage of using the std::vector class to store elements compared to plain arrays, is that the delete keyword does not have to be invoked.  However, developers should be careful when using plain arrays for 2-D arrays.  When the 2-D array is used, the array has to be deallocated after initialization.  Failure to deallocate the memory will result in a memory leak due to C++ not having any garbage collection.  A reason for why a developer would want to utilize a plain array rather than use the std::vector class is to store a larger amount of elements and avoid the slight overhead which comes with utilizing the std::vector class.

When handling 2-D arrays, there should be care about how the program handles memory as well as accessing the array elements.  Traversal of the 2-D array is a great example, where it is recommended to traverse through columns using the inner portion of a nested loop and the row traversal being executed by the outer loop.  This would prevent the program from jumping to new memory locations to access elements within the array since the values are stored within contiguous blocks of memory.  Changing the iteration, by having the inner loop traverse the columns and the outer traverse the rows, will result in a slower execution time which would be problematic for larger inputs.

2-D Array: Use Cases

2-D Array: Example - Linear Algebra Operations

Dot Product

Cross Product

Matrix Multiplication

                        </a>
                        <div class="info-post">
                                <a href="/Data%20Structures" class="category">Data Structures</a>
                            
                                <span class="date">· 2025-05-19</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Asymptotic%20Notation/Introduction%20to%20Asymptotic%20Notation.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/bigograph.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Asymptotic%20Notation/Introduction%20to%20Asymptotic%20Notation.html"><h1 class="title_post">Introduction to Asymptotic Notation</h1></a>
                        <a href="/Asymptotic%20Notation/Introduction%20to%20Asymptotic%20Notation.html" class="txt_post">
                            
  “The key to performance is elegance, not batallions of special cases.”
Doug Bently and Jon Mcllroy


When thinking about software, there are different components which can work together to create a tool which can help users organize and retrieve large stores of information.  Programmers use a variety of tools to measure the performance of the algorithm which drives the solution.  The basket of tools that are deployed to measure performance of the program depends on the attribute that is being assessed (such as user friendliness, data integrity, etc.). However, the attribute that will be discussed is the theoretical performance of what powers the solutions.  So while there are many different ways to determine whether the software meets the requirements of the users, the focus will fall mostly on the assessment of the runtime and spacetime complexities of the solutions.

How to Assess Performance of Programs
There are different variables which may impact the runtime performance of programs which include environmental factors such as hardware.  However, when dealing with algorithms, it would be ideal to ignore those environmental factors and focus on comparing the number of operations that the algorithm will perform on the input.  By not taking hardware into account, we can see the limitations of the algorithms that are being compared.  To put it into better wording, an inefficient algorithm being executed in a modern computing environment may be able to achieve seemingly better results than an effecient algorith being executed in an legacy computing environment.

To better assess the performance of programs, different notations are used to gain a better understanding of the theoretical limits of the algorithms.  ‘Big O’ notation is used as a means to gain a general idea of the worst-case performance or upper-bound limit of the algorithm.  ‘Big Theta’ notation is encased between Big O and Big Omega notations, giving the average complexity of the algorithm.  And as previously mentioned, ‘Big Omega’ sits below Big Theta, giving the lower-bound limit or best-case performance of the algorithm.

Big O Notation
The first complexity notation which will be discussed is Big O, or Big Order, notation.  It is also called the theoretical upper-bound limit or the worst-case complexity.  When analyzing the runtime complexity of different algorithms, one of the most frequently considered is the worst-case performance to assess the scalability of the solution.  In other words, when looking at the scalability, we are interested in how many operations are being performed by the algorithm as the input size increases.  By assessing the worst-case scenario, there can be more confidence in asserting the scalability of the solution.  The question, “what is the most amounts of operations that this algorithm is going to perform?” can be answered by big-O notation.

Another way to think of big O notation is as a comparison between the growth of different functions.  As previously mentioned, there are many other factors which can impact how ‘fast’ in literal time it takes for the program to execute.  However, when looking at big O notation, the goal is to simplify the function as much as possible.  This would mean that, in practice, the environmental factors such as programming language or hardware is expressed in terms of constants.  By simplifying the expression of the functions, the constants can be dropped in order to assess the growth rates of the functions. So, for example the function:
\(T(n) = 10000 + 10(n)\)
can be used to express a program which takes 10000 ms to load and 10 ms to execute each transaction.  Both the 10000 ms and 10 ms are reliant on factors outside of the algorithm itself.  These constants can change when improvements are made to the environment which is executing the program.  However the equation can be simplified to ignore the constants, giving us
\(T(n) \in O(f(n))\)
With the simplified run time, it becomes much easier to compare the performance of the algorithms.  This can allow us to have a more formal definition of what is big O.


  \(T(n) \in O(f(n))\) if and only if \(T(n) \leq cf(n)\), where c is some constant


This definition shows that the focal point of the analysis would be set at the point at which the growth of \(cf(n)\) overtakes the growth of \(T(n)\).  It also establishes that big O is not necessarily just a quantity or a metric, but is more than that.  Big O describes the set of all functions which satisfy:


  There exists positive constants \(c\), \(N\) such that, for all \(n \geq N\), \(T(n) \leq cf(n)\)
where \(N\) is the point at which \(T(n) \leq cf(n)\)


As shown, big O is mostly conserned with expressing the upper bound limit of a function, thus will not be revealing much on the lower bound.  This means that while it is possible to use big O notation to establish the higher performance of a function compared to another, it does not reveal the lower bound.  So to prove that the function is slower, another notation is needed (Omega (Ω)).

Big Omega (Ω) Notation
While Big O measures the upper bound or worst-case performance of a function, Big Ω looks at the lower bound of the function.  This means that big omega notation would reveal the best-case performance of a function which means that the notation measures the function’s minimal amount of runtime and space complexity.  Just as previously mentioned with big O, big Ω notation examines the set of possible functions to fit certain criteria.  To provide a more mathematical understanding of big Ω notation, the following definition can provide a baseline understandng:


  Given Two functions, \(f(n)\) and \(g(n)\), we can say \(f(n) = Ω(g(n))\) if there exists constants \(c \gt 0\) and \(n_{o} \ge 0\) such that \(f(n) \ge c\cdot g(n)\) for all \(n \ge n_{o}\).


From the definition, we can gather that Ω notation provides the justification of whether a function \(f(n)\) will grow faster than another function multiplied by a constant, \(c\cdot g(n)\).  This establishes Ω notation as a reliable measure of the best-case performance of a function, or its lower-bound asymptotic growth.

The steps to defining the Ω notation of a functions goes as follows:
    1. Break the function into smaller, modular segments.
    2. Find the complexity of each segment.
    3. Add the constants together and drop the constants.

By following the steps, the Ω notation can be guarteed to establish the tight lower bound of the function, and give a good estimate of what the best case performance of the algorithm is.

While it can be very useful and revealing, big Ω notation is not frequently used to analyze the function’s asymptotic growth compared to Big O notation.  The main reason for why the notation is not used is because the notation gives an accurate but imprecise measure of function performance.  For example, say we define a function such that:

function(input list: n, element)
    do
    compare (list[index] == element)
        true -&gt; stop
        false -&gt; continue


In other words, the defined function will perform a linear search on an input and stop once the matching element is found.  The best case performance for the algorithm can be O(1), since the first element encountered can come as a match.  However, this is not necessarily precise since the algorithm will not perform in constant time most of the time.  For this reason, big Ω notation is not used frequently to analyze and compare algorithmic performance due to its imprecise nature.

Big Theta (Θ) Notation
While big O returns the upper-bound and big Ω returns the lower-bound of the function, big Θ returns the average growth of the function.  Also, big Θ returns more precise results compared to big Ω due to the average case needing to compute the upper and lower bounds of the function.  The definition of big Θ notation goes as follows:


  Let g and f be functions, f is said to be Θ(g) if there are two constants \(c_{1}, c_{2} \gt 0\) and a natural number \(n_{0}\) such that \(c_{1} \cdot g(n) \le f(n) \le c_{2} \cdot g(n)\) for all \(n \ge n_{0}\).


In other words, if a function f is Θ(g), the values of f will be encased between the function g(n) multiplied by two constants, \(c_{1}\) and \(c_{2}\).  This guarantees that the Θ notation will give the average case of the function.  So by providing the upper and lower bounds of the function, the notation can find the average case complexity of the function.  This precise measure can be useful as well as powerful when analyzing the asymptotic growth of the function.

To find the average complexity of the function, the high level overview of the steps are similar to finding the Ω notation with several differences:
    1. Break the function into smaller segments.
    2. Find all possible inputs for the algorithm.
    3. Calculate the amount of operations that can be performed on the input.
    4. Divide the amount of operations by the number of segments to find the average of all complexities.

So, if Θ notation encapsulates both upper and lower bounds, why isn’t it mentioned more frequently?  Might be a question that may be asked.  This is because, as algorithms become more complex, it becomes more difficult to be able to find all possible inputs and then calculate the operations.  In this case, many will default to using big O notation to find the upper-bound limit of the function’s asymptotic growth.  While Θ notation is precise, it can be a complex process to be able to return any useful information from analysis, so big O notation is more applicable in this scenario since it reveals more than Θ notation.

Common Runtimes of Algorithms


From this point, the runtimes that will be discussed will mainly be in big O, due to the frequency of its use.  When discussing different runtimes, the default which is used is big O notation.  While there are many different runtimes, the most common run times are factorial, exponential, polynomial, linear, and constant.  These all describe asymptotic growth patterns of different algorithms into 5 general categories of runtimes.  This allows programmers to compare the efficiency of different solutions by supposing an infinite or progressively larger input size.  These aren’t only used to analyze runtime, they can also be used to analyze space-time complexity.  Space-time complexity measures how well a solution works with memory, assessing whether it is efficient or a horrible use of memory.  It is generally accepted that complexities which are exponential and factorial scale very badly, whereas solutions in polynomial, linear, or constant time scale very well.

Factorial
This is considered the worst possible complexity.  This general set of solutions run at a complexity of O(n!), hence the name.  These solutions are extraordinarily terrible to scale as demonstrated in the above graph relative to other complexities.  One of the important aspects to notice is the near immediate increase in the amount of operations which is performed by the solution.  Most solutions which fall within this category of complexity are generally considered extraordinarily innefficient and impractical.  However, there can be instances where factorial runtimes can be useful, such as proposing a brute-force solution to an unsolved problem.
Examples of algorithms with factorial runtimes include:

  Travelling salesman (Brute force)
  Generating all possible permutations of a set
  Password cracking (Brute force)
  Bogosort


Each of the previously mentioned algorithms are brute force algorithms which try every possible combination until the solution is reached.  For instance, bogosort is a simple two step solution which takes an input which is comprised of elements which can be sorted and randomly shuffles the elements until they are confirmed sorted.  As such the algorithm can be broken down into two segments, where the shuffling of elements create O(\(n!\)) runtime and the confirmation of whether the elements are sorted reveal an O(\(n\)) runtime.  By combining these runtimes, we get O(\(n! + n\)) upper bound, or O(\(n!\)).
As previously mentioned, these algorithms are considered generally useless due to its impractical nature when it comes to scaling.  However, the importance of solutions with factorial runtimes is due to the problem being novel and, normally, there not being any previously established solution.  It is encouraged to try and find a more efficient solution to allow for its nature to be practical in the context of ‘the real world’.

Exponential
While somewhat an improvement from factorial, exponential runtimes are still very terrible at scaling and still encompass some brute force solution.  On the above graph, the asymptotic complexity is shown to grow faster than all other runtime complexities on the graph other than factorial.  Exponential solutions scale upwards at a rate of \(n^n\), hence its big O complexity is notated O(\(n^n\)).
Some examples of algorithms that have exponential runtimes include:

  Naive solution to the n-queens problem
  Generating the Fibonacci sequence (recursive)


Each of the previous algorithms approach the problem in an naive way and is still considered generally impractical due to its inability to scale to be applied to larger sets.  For example, when solving for the n-th Fibonacci number recursively, the algorithm returns the solution by first generating a recursion tree from a base case of 1.  The function calls are then pushed onto a callstack and then popped to return the solution.  One of the most important characterstics of this runtime is that it encompasses naive approaches just like factorial solutions.  This means that while the solutions may be hard to apply to larger inputs, the importance of improving upon an naive solution like the previously mentioned solutions should not be dismissed.

Polynomial
Polynomial runtimes, generally notated as O(\(n \cdot log(n)\)) but officially defined O(\(n^k\)), are the first set of functions and solutions which are considered practical for larger sets.  Also, the runtime O(\(n^2\)) is considered its own category, quadratic, despite the runtime seemingly mapping to exponential runtime.  Algorithms with quadratic runtimes are also considered poloynomial, so they can be defined as a subset of solutions which have polynomial runtimes.

The set of functions which have polynomial runtimes can scale well as the input size increases relative to exponential and factorial growth rates, as seen in the graph above.  There are plenty of different sorting algorithns, string parsing solutions, backtracking solutions, etc. which can have a polynomial runtimes.  More familiar examples of algorithms which are considered polynomial time inclulde the operations used in arithmetics such as addition, multiplication, division, and subtraction.

Polynomial runtimes are considered “fast” and are frequently encountered within the area of algorithmic analysis, due to its smoother growth rate relative to the other previously mentioned growth patterns.

Linear
One of the introductory searching algorithms that computer science students are shown is the linear search.  The linear search algorithm is very simple:
Input: A list of elements, element to find

1. Start at the beginning entry
2. Compare the element to the input element to see if they are matching
3. If match: Return the index of the matched element
   If not matched: Continue to the next index

This is an example of an algorithm or solution which has a linear, or O(\(n\)), worst case runtimes.  The reason is because as the input size grows, the worst case scenario is for the algorithm to not find any matches within the list.  In this case, it will traverse the entire list and return false.  With this understanding, there are other examples of solutions which run in linear time which might be as intuitive as linear search:

  Deleting and item from a linked list
  Checking if a string is a palindrome


Algorithms which run in linear time are considered very fast, however can lead to problems when the input size increases to larger amounts.  Generally, linear searches perform worse when the list size begins to increase to larger sizes.

Constant
Functions which run in constant time are considered the best since it will take the same amount of time to execute the solution, no matter how large the size is.  Often denoted as O(1), there are different examples of solutions which run in constant time.  For example, if we are given an indexed list such as an array, returning an element in the array based on the index would run in constant time.  The idea being, if there was an indexed list of elements, returning the seventh element of the list would take about the same amount of time no matter the size of the list whether it is 10, 100, or 1000 elements large. Some examples of well-known indexed lists include:

  Hash maps
  Arrays
  Databases


All of these can be ideal if the goal is to store and retrieve the elements frequently.  Execution of a retrieval function would not take long and would not change as the input size increases.  This can allow for the solution to offer a mechanism of consistency within runtime complexities.

                        </a>
                        <div class="info-post">
                                <a href="/Asymptotic%20Notation" class="category">Asymptotic Notation</a>
                            
                                <span class="date">· 2025-05-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>
    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "Asymptotic Notation",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Asymptotic%20Notation/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Arrays",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Arrays/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Balanced Trees",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Balanced%20Trees/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Binary Search Trees",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Binary%20Search%20Trees/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Binary Trees",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Binary%20Trees/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Complete Binary Trees",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Complete%20Binary%20Trees/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Full Binary Tree",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Full%20Binary%20Tree/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Linked Lists",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Linked%20Lists/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Queues",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Queues/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Stacks",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Stacks/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures > Unbalanced Trees",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/Unbalanced%20Trees/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Data Structures",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Data%20Structures/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Introduction to Asymptotic Notation",
            'path'     : "Asymptotic Notation",
            'type'     : "post",
            'tags'     : "",
            'url'      : "/Asymptotic%20Notation/Introduction%20to%20Asymptotic%20Notation.html",
            'image'    : "/assets/img/thumbnail/bigograph.jpg",
            'date'     : "2025-05-12"
        });
    

        posts.push({
            'title'    : "2-D Arrays: Introduction and Examples",
            'path'     : "Data Structures > Arrays",
            'type'     : "post",
            'tags'     : "",
            'url'      : "/Data%20Structures/Arrays/2-D%20Arrays.html",
            'image'    : "/assets/img/thumbnail/2Darray.png",
            'date'     : "2025-05-19"
        });
    

        posts.push({
            'title'    : "Dynamic Arrays: Let&#39;s Create and Use One",
            'path'     : "Data Structures > Arrays",
            'type'     : "post",
            'tags'     : "",
            'url'      : "/Data%20Structures/Arrays/Dynamic%20Arrays.html",
            'image'    : "/assets/img/thumbnail/dynamicarray.png",
            'date'     : "2025-05-19"
        });
    

        posts.push({
            'title'    : "Introduction to Arrays",
            'path'     : "Data Structures > Arrays",
            'type'     : "post",
            'tags'     : "",
            'url'      : "/Data%20Structures/Arrays/Introduction%20to%20Arrays.html",
            'image'    : "/assets/img/thumbnail/arraypic.gif",
            'date'     : "2025-05-19"
        });
    

        posts.push({
            'title'    : "Jagged Arrays: Taking Them to the Next Level",
            'path'     : "Data Structures > Arrays",
            'type'     : "post",
            'tags'     : "",
            'url'      : "/Data%20Structures/Arrays/Jagged%20Arrays.html",
            'image'    : "/assets/img/thumbnail/jaggedarray.png",
            'date'     : "2025-05-19"
        });
    

        posts.push({
            'title'    : "Introduction to Linked Lists",
            'path'     : "Data Structures > Linked Lists",
            'type'     : "post",
            'tags'     : "",
            'url'      : "/Data%20Structures/Linked%20Lists/Introduction%20to%20Linked%20Lists.html",
            'image'    : "/assets/img/thumbnail/linkedlist.jpg",
            'date'     : "2025-06-09"
        });
    

        posts.push({
            'title'    : "Introduction to Linked Lists: Doubly Linked Lists",
            'path'     : "Data Structures > Linked Lists",
            'type'     : "post",
            'tags'     : "",
            'url'      : "/Data%20Structures/Linked%20Lists/Doubly%20Linked%20Lists.html",
            'image'    : "/assets/img/thumbnail/doublylinkedlist.gif",
            'date'     : "2025-06-13"
        });
    

    searchPost(posts);

    
</script>
</html>
